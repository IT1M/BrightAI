(function () { "use strict"; function loadCSS(href) { var link = document.createElement("link"); link.rel = "stylesheet", link.href = href, document.head.appendChild(link) } function loadScript(src, callback) { var script = document.createElement("script"); script.src = src, script.async = !0, callback && (script.onload = callback), document.body.appendChild(script) } function initSwipers() { if (!(typeof Swiper > "u")) { var sliders = document.querySelectorAll(".testimonials-slider"); sliders.forEach(function (el) { if (!el.swiper) { var paginationEl = el.querySelector(".swiper-pagination"); new Swiper(el, { loop: !0, slidesPerView: 1, spaceBetween: 24, autoplay: { delay: 5e3, disableOnInteraction: !1 }, pagination: paginationEl ? { el: paginationEl, clickable: !0 } : void 0, breakpoints: { 768: { slidesPerView: 2 }, 1024: { slidesPerView: 3 } } }) } }) } } var isMobile = window.matchMedia("(max-width: 768px)").matches, prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches, isLowPower = navigator.connection && (navigator.connection.saveData || navigator.connection.effectiveType === "2g" || navigator.connection.effectiveType === "slow-2g"), skipHeavy = isMobile || isLowPower || prefersReducedMotion; function loadDeferredResources() { var hasAos = document.querySelector("[data-aos]") !== null, hasSwiper = document.querySelector(".swiper, .testimonials-slider") !== null; hasAos && !skipHeavy && loadCSS("https://unpkg.com/aos@2.3.4/dist/aos.css"), hasSwiper && loadCSS("https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css"), loadScript("https://code.iconify.design/iconify-icon/2.0.0/iconify-icon.min.js") } function loadAnimations() { skipHeavy ? console.log("[Performance] Heavy animations disabled for mobile/low-power device") : (loadScript("https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js", function () { loadScript("https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js") }), loadScript("https://unpkg.com/aos@2.3.4/dist/aos.js", function () { typeof AOS < "u" && AOS.init({ duration: 800, once: !0, offset: 100 }) }), loadScript("https://cdn.jsdelivr.net/npm/typed.js@2.0.16/dist/typed.umd.js")); var swiperElements = document.querySelectorAll(".swiper"); swiperElements.length > 0 && loadScript("https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js", initSwipers) } document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", function () { "requestIdleCallback" in window ? requestIdleCallback(loadDeferredResources, { timeout: 1500 }) : setTimeout(loadDeferredResources, 50), setTimeout(loadAnimations, 300) }) : (loadDeferredResources(), setTimeout(loadAnimations, 300)) })(), function () { "use strict"; function initNavigation() { const nav = document.querySelector(".unified-nav"); if (!nav) return; const mobileToggle = document.querySelector(".mobile-toggle"), mobileDrawer = document.querySelector(".mobile-menu-drawer"), backdrop = document.querySelector(".backdrop-overlay"), dropdownToggles = document.querySelectorAll('.nav-link[aria-haspopup="true"]'); window.addEventListener("scroll", () => { window.scrollY > 20 ? (nav.style.background = "rgba(2, 6, 23, 0.95)", nav.style.boxShadow = "0 10px 30px -10px rgba(0,0,0,0.5)") : (nav.style.background = "rgba(2, 6, 23, 0.85)", nav.style.boxShadow = "none") }, { passive: !0 }); function toggleMobileMenu() { if (!mobileToggle || !mobileDrawer) return; const isExpanded = mobileToggle.getAttribute("aria-expanded") === "true"; mobileToggle.setAttribute("aria-expanded", !isExpanded), isExpanded ? (mobileDrawer.classList.remove("active"), backdrop && backdrop.classList.remove("active"), document.body.style.overflow = "") : (mobileDrawer.classList.add("active"), backdrop && backdrop.classList.add("active"), document.body.style.overflow = "hidden") } mobileToggle && mobileToggle.addEventListener("click", toggleMobileMenu), backdrop && backdrop.addEventListener("click", toggleMobileMenu), document.addEventListener("keydown", e => { e.key === "Escape" && mobileDrawer && mobileDrawer.classList.contains("active") && toggleMobileMenu() }), dropdownToggles.forEach(toggle => { const navItem = toggle.closest(".nav-item"), dropdown = toggle.nextElementSibling; if (!navItem || !dropdown) return; let closeTimer = null; const cancelClose = () => { closeTimer && (clearTimeout(closeTimer), closeTimer = null) }, scheduleClose = () => { closeTimer = setTimeout(() => { toggle.getAttribute("aria-expanded") === "true" && toggle.setAttribute("aria-expanded", "false") }, 500) }; navItem.addEventListener("mouseenter", () => { window.innerWidth >= 1024 && (cancelClose(), toggle.setAttribute("aria-expanded", "true")) }), navItem.addEventListener("mouseleave", () => { window.innerWidth >= 1024 && scheduleClose() }), dropdown.addEventListener("mouseenter", () => { window.innerWidth >= 1024 && cancelClose() }), dropdown.addEventListener("mouseleave", () => { window.innerWidth >= 1024 && scheduleClose() }), toggle.addEventListener("keydown", e => { (e.key === "Enter" || e.key === " ") && (e.preventDefault(), toggle.setAttribute("aria-expanded", toggle.getAttribute("aria-expanded") === "true" ? "false" : "true")) }) }); const mobileDropdownToggles = document.querySelectorAll('.mobile-nav-link[aria-haspopup="true"]'); mobileDropdownToggles.forEach(toggle => { toggle.addEventListener("click", e => { e.preventDefault(); const submenu = toggle.nextElementSibling, isExpanded = toggle.getAttribute("aria-expanded") === "true"; isExpanded || mobileDropdownToggles.forEach(other => { if (other !== toggle) { other.setAttribute("aria-expanded", "false"); const otherSub = other.nextElementSibling; otherSub && otherSub.classList.contains("mobile-dropdown") && otherSub.classList.remove("open") } }), toggle.setAttribute("aria-expanded", !isExpanded), submenu && submenu.classList.toggle("open") }) }), document.querySelectorAll(".dropdown-item").forEach(item => { item.addEventListener("click", () => { console.log("Navigating to:", item.getAttribute("href")) }) }) } document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", initNavigation) : initNavigation() }(), function () { "use strict"; const ComponentLoader = { loadedComponents: new Set, loadQueue: [], isLoading: !1, async load(componentPath, targetSelector, options = {}) { const { insertPosition = "replace", onLoad = null, onError = null, cache = !0 } = options; if (cache && this.loadedComponents.has(componentPath)) return; const targetElement = document.querySelector(targetSelector); if (!targetElement) { onError && onError(new Error(`Target not found: ${targetSelector}`)); return } try { this.showLoadingState(targetElement); const response = await fetch(componentPath); if (!response.ok) throw new Error(`HTTP ${response.status}`); const html = await response.text(); this.insertContent(targetElement, html, insertPosition), this.executeScripts(targetElement), cache && this.loadedComponents.add(componentPath), onLoad && onLoad(targetElement) } catch (error) { console.error("[ComponentLoader] Error:", error), this.showErrorState(targetElement), onError && onError(error) } }, insertContent(element, html, position) { switch (position) { case "replace": element.innerHTML = html; break; case "before": element.insertAdjacentHTML("beforebegin", html); break; case "after": element.insertAdjacentHTML("afterend", html); break; case "prepend": element.insertAdjacentHTML("afterbegin", html); break; case "append": element.insertAdjacentHTML("beforeend", html); break } }, executeScripts(container) { container.querySelectorAll("script").forEach(oldScript => { const newScript = document.createElement("script"); Array.from(oldScript.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value)), newScript.textContent = oldScript.textContent, oldScript.parentNode.replaceChild(newScript, oldScript) }) }, showLoadingState(element) { element.innerHTML = '<div style="padding:20px;text-align:center;opacity:0.5">Loading...</div>' }, showErrorState(element) { element.innerHTML = '<div style="padding:20px;text-align:center;color:red">Error loading content</div>' }, lazyLoad(selector, componentPath, options = {}) { const elements = document.querySelectorAll(selector), observer = new IntersectionObserver((entries, obs) => { entries.forEach(entry => { entry.isIntersecting && (this.load(componentPath, selector, options), obs.unobserve(entry.target)) }) }, { rootMargin: "100px", threshold: .1 }); elements.forEach(el => observer.observe(el)) } }; window.ComponentLoader = ComponentLoader, document.addEventListener("DOMContentLoaded", function () { document.querySelectorAll("[data-lazy-component]").forEach(el => { const componentPath = el.dataset.lazyComponent, targetSelector = el.dataset.lazyTarget || `#${el.id}`; ComponentLoader.lazyLoad(targetSelector, componentPath, { onLoad: () => { typeof AOS < "u" && AOS.refresh() } }) }) }) }(), function () {
    "use strict"; function initHomepageLogic() { const scheduleIdle = (fn, timeout = 1200) => { typeof fn == "function" && ("requestIdleCallback" in window ? requestIdleCallback(fn, { timeout }) : setTimeout(fn, Math.min(300, timeout))) }; try { initDynamicYear() } catch { } try { scheduleIdle(initMedicalArchiveCanvas, 1500) } catch (e) { console.warn("Canvas init failed", e) } try { scheduleIdle(initCounters, 1200) } catch (e) { console.warn("Counters init failed", e) } try { scheduleIdle(initScrollAnimations, 1200) } catch { } try { scheduleIdle(initFaqTabs, 800) } catch { } try { scheduleIdle(initFeatureTabs, 800) } catch { } } function initDynamicYear() { const year = String(new Date().getFullYear()); document.querySelectorAll(".copyright-year").forEach(el => { el.textContent = year }) } function initMedicalArchiveCanvas() { const canvas = document.getElementById("medical-archive-canvas"); if (!canvas) return; const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches, isLowPower = navigator.connection && (navigator.connection.saveData || navigator.connection.effectiveType === "2g" || navigator.connection.effectiveType === "slow-2g"); if (prefersReducedMotion || isLowPower) return; const ctx = canvas.getContext("2d"); if (!ctx) return; let isRunning = !1, rafId = null; function resize() { canvas.width = canvas.offsetWidth, canvas.height = canvas.offsetHeight } function buildParticles() { const particles2 = [], count = Math.min(24, Math.max(16, Math.floor(canvas.width * canvas.height / 6e4))); for (let i = 0; i < count; i++)particles2.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, z: Math.random() * 1e3, vx: (Math.random() - .5) * .5, vy: (Math.random() - .5) * .5, vz: (Math.random() - .5) * 2, radius: Math.random() * 2 + 1, color: Math.random() > .5 ? "#06b6d4" : "#10b981" }); return particles2 } let particles = []; function animate() { if (isRunning) { if (canvas.width === 0 || canvas.height === 0) { rafId = requestAnimationFrame(animate); return } ctx.clearRect(0, 0, canvas.width, canvas.height), particles.forEach(p => { p.x += p.vx, p.y += p.vy, p.z += p.vz, (p.x < 0 || p.x > canvas.width) && (p.vx *= -1), (p.y < 0 || p.y > canvas.height) && (p.vy *= -1), p.z < 0 ? (p.z = 0, p.vz *= -1) : p.z > 1e3 && (p.z = 1e3, p.vz *= -1); const scale = Math.max(0, (1e3 - p.z) / 1e3), size = p.radius * scale; !Number.isFinite(size) || size <= 0 || (ctx.globalAlpha = Math.min(.6, scale * .5), ctx.beginPath(), ctx.arc(p.x, p.y, size, 0, Math.PI * 2), ctx.fillStyle = p.color, ctx.fill(), ctx.globalAlpha = 1) }), rafId = requestAnimationFrame(animate) } } function start() { isRunning || (resize(), particles = buildParticles(), isRunning = !0, animate()) } function stop() { isRunning = !1, rafId && cancelAnimationFrame(rafId) } window.addEventListener("resize", () => { resize(), particles = buildParticles() }), "IntersectionObserver" in window ? new IntersectionObserver(entries => { entries.forEach(entry => { entry.isIntersecting ? start() : stop() }) }, { rootMargin: "100px 0px", threshold: .01 }).observe(canvas) : start() } function initCounters() { const counters = document.querySelectorAll(".counter"), observer = new IntersectionObserver(entries => { entries.forEach(entry => { if (entry.isIntersecting) { let update = function (time) { const elapsed = time - startTime, progress = Math.min(elapsed / duration, 1), current = start + (target - start) * (1 - Math.pow(1 - progress, 4)); counter.textContent = current.toFixed(1), progress < 1 && requestAnimationFrame(update) }; const counter = entry.target, target = parseFloat(counter.getAttribute("data-target")); let start = 0; const duration = 2e3, startTime = performance.now(); requestAnimationFrame(update), observer.unobserve(counter) } }) }, { threshold: .5 }); counters.forEach(c => observer.observe(c)) } function initScrollAnimations() { const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches, elements = document.querySelectorAll(".feature-card-3d, .benefit-card-3d"); if (elements.length === 0) return; if (prefersReducedMotion) { elements.forEach(el => { el.style.opacity = "1", el.style.transform = "none", el.style.transition = "none" }); return } const observer = new IntersectionObserver(entries => { entries.forEach((entry, index) => { entry.isIntersecting && (entry.target.style.opacity = "1", entry.target.style.transform = "translateY(0)", entry.target.style.transitionDelay = `${index * .1}s`) }) }, { threshold: .1 }); elements.forEach(el => { el.style.opacity = "0", el.style.transform = "translateY(30px)", el.style.transition = "all 0.6s ease-out", observer.observe(el) }) } function initFaqTabs() { document.querySelectorAll(".faq-toggle").forEach(el => { el.hasAttribute("aria-expanded") || el.setAttribute("aria-expanded", "false") }), window.switchFaqTab = function (category, btn) { document.querySelectorAll(".faq-category").forEach(el => el.classList.add("hidden", "block")), document.querySelectorAll(".faq-category").forEach(el => el.classList.remove("block")), document.querySelectorAll(".faq-category").forEach(el => el.classList.add("hidden")); const selected = document.getElementById("faq-" + category); selected && (selected.classList.remove("hidden"), selected.classList.add("block")), document.querySelectorAll(".faq-tab").forEach(el => { el.classList.remove("active", "border-gold-500/20", "bg-gold-500/10", "text-gold-400"), el.classList.add("border-white/5", "bg-white/5", "text-slate-400") }), btn.classList.remove("border-white/5", "bg-white/5", "text-slate-400"), btn.classList.add("active", "border-gold-500/20", "bg-gold-500/10", "text-gold-400") }, window.toggleFaq = function (btn) { if (!btn) return; const item = btn.closest(".faq-item"); if (!item) return; const content = item.querySelector(".faq-content"), icon = item.querySelector(".faq-icon"), isOpen = content && !content.classList.contains("hidden"); document.querySelectorAll(".faq-content").forEach(el => el.classList.add("hidden")), document.querySelectorAll(".faq-icon").forEach(el => { el.style.transform = "" }), document.querySelectorAll(".faq-toggle").forEach(el => el.setAttribute("aria-expanded", "false")), content && !isOpen && (content.classList.remove("hidden"), icon && (icon.style.transform = "rotate(180deg)"), btn.setAttribute("aria-expanded", "true")) } } function initFeatureTabs() {
        const featureContent = { vision: { icon: "lucide:scan-face", color: "indigo", title: "\u062F\u0642\u0629 \u0627\u0644\u062A\u0634\u062E\u064A\u0635", value: "98.5%" }, predict: { icon: "lucide:bar-chart-3", color: "purple", title: "\u062F\u0642\u0629 \u0627\u0644\u062A\u0646\u0628\u0624", value: "94.2%" }, hospital: { icon: "lucide:activity-square", color: "green", title: "\u0643\u0641\u0627\u0621\u0629 \u0627\u0644\u0639\u0645\u0644\u064A\u0627\u062A", value: "87.8%" }, gemini: { icon: "lucide:bot", color: "gold", title: "\u0631\u0636\u0627 \u0627\u0644\u0645\u0633\u062A\u062E\u062F\u0645", value: "96.1%" } }; window.updateFeature = function (featureKey, btn) {
            const feature = featureContent[featureKey], container = document.getElementById("feature-content"); !container || !feature || (container.innerHTML = `
                <iconify-icon icon="${feature.icon}" width="64" class="text-${feature.color}-400"></iconify-icon>
                <div class="w-3/4 space-y-3">
                    <div class="h-2 bg-${feature.color}-500/20 rounded-full w-full overflow-hidden">
                        <div class="h-full bg-${feature.color}-500" style="width: ${feature.value}"></div>
                    </div>
                    <div class="flex justify-between text-xs text-${feature.color}-300">
                        <span>${feature.title}</span><span>${feature.value}</span>
                    </div>
                </div>
                <div class="grid grid-cols-3 gap-4 w-full mt-4">
                     <div class="h-24 bg-white/5 rounded-lg border border-white/5 animate-pulse"></div>
                     <div class="h-24 bg-white/5 rounded-lg border border-white/5"></div>
                     <div class="h-24 bg-white/5 rounded-lg border border-white/5"></div>
                </div>`
                , document.querySelectorAll(".tab-btn").forEach(el => el.classList.remove("active")), btn.classList.add("active"))
        }
    } document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", initHomepageLogic) : initHomepageLogic()
}(); (function () { "use strict"; const lazySections = new Map; let sectionObserver = null; function initLazySections() { const placeholders = document.querySelectorAll("[data-lazy-section]"); placeholders.length !== 0 && (sectionObserver = new IntersectionObserver(entries => { entries.forEach(entry => { entry.isIntersecting && (loadSection(entry.target), sectionObserver.unobserve(entry.target)) }) }, { rootMargin: "200px 0px", threshold: .01 }), placeholders.forEach(el => sectionObserver.observe(el))) } async function loadSection(placeholder) { const sectionUrl = placeholder.dataset.lazySection, sectionId = placeholder.id || "unknown"; if (sectionUrl) { placeholder.classList.add("lazy-section-loading"); try { const response = await fetch(sectionUrl); if (!response.ok) throw new Error(`HTTP ${response.status} `); const html = await response.text(); placeholder.innerHTML = html, placeholder.classList.remove("lazy-section-loading"), placeholder.classList.add("lazy-section-loaded"), placeholder.querySelectorAll("script").forEach(old => { const newScript = document.createElement("script"); Array.from(old.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value)), newScript.textContent = old.textContent, old.parentNode.replaceChild(newScript, old) }), typeof AOS < "u" && AOS.refresh(), typeof Iconify < "u" && Iconify.scan(placeholder), placeholder.dispatchEvent(new CustomEvent("sectionLoaded", { detail: { sectionId, sectionUrl } })) } catch (error) { console.error(`[Lazy] Error loading ${sectionId} `, error), placeholder.innerHTML = '<div class="text-red-500 p-4 text-center">Error loading section</div>' } } } document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", initLazySections) : initLazySections() }());

// Smooth Scroll for anchor links
function initSmoothScroll() {
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            const targetId = this.getAttribute("href");
            if (targetId === "#") return;
            const targetElement = document.querySelector(targetId);
            if (targetElement) {
                // Close mobile menu if open
                const mobileDrawer = document.querySelector(".mobile-menu-drawer");
                const mobileToggle = document.querySelector(".mobile-toggle");
                const backdrop = document.querySelector(".backdrop-overlay");

                if (mobileDrawer && mobileDrawer.classList.contains("active")) {
                    mobileDrawer.classList.remove("active");
                    if (backdrop) backdrop.classList.remove("active");
                    if (mobileToggle) mobileToggle.setAttribute("aria-expanded", "false");
                    document.body.style.overflow = "";
                }

                targetElement.scrollIntoView({
                    behavior: "smooth",
                    block: "start"
                });
            }
        });
    });
}
document.addEventListener("DOMContentLoaded", initSmoothScroll);
